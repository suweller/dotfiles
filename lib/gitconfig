[core]
  excludesfile = ~/.gitignore
  attributesfile = ~/.gitattributes
  pager = less \
      --no-init \
      --quit-if-one-screen \
      --raw-control-chars \
      --tabs=4

[user]
  name = Steven Weller
  email = github@suweller.com

[github]
  user = suweller

[alias]
  aliases = !git config --global --get-regexp ^alias | sed -e 's/^alias./  /'
  cloc = !cloc $(git ls-files)
  c = commit --verbose
  co = checkout
  s = status --short --branch
  d = diff
  a = add --patch
  b = branch --verbose

  ba = for-each-ref \
    --sort=authordate refs/remotes \
    --format='\
%(color:red)%(objectname:short) \
%(align:20,left)%(color:green)%(authordate:relative)%(end) \
%(align:20,left)%(color:blue)%(authorname)%(end) \
%(color:reset)%(refname:strip=3)'
  stale = !git ba | ag --invert-match '(days|hours|minutes) ago'

  l = log \
    --decorate=short \
    --format='\
%C(red)%h %C(reset)\
%C(green)%<(6,trunc)%cr %C(reset)\
%C(blue)%<(8,trunc)%an %C(reset)\
%<(72,trunc)%s \
%C(auto)%D%C(reset)'
  ll = !git l --numstat $@

  main-branch = !ag \
    --nocolor \
    --only-matching \
    '(?<=^\\[branch \")[^\"]*(?=\"\\]$)' \
    .git/config \
    | head -1 \
    | tr -d '\\012\\015'
  current-branch = symbolic-ref --short HEAD
  fork-point = !sh -c 'git merge-base --fork-point $(git main-branch)'
  fork-range = !sh -c 'echo $(git fork-point)..$(git main-branch)'
  fork-lag = !sh -c 'git rev-list --count $(git fork-range)'
  fork-behind = !sh -c 'git l $(git fork-point)...$(git main-branch)'
  fork-l = !sh -c 'git l $(git fork-point)...HEAD'
  fork-touched = !sh -c ' \
    ( \
    git -c color.status=always status --short --untracked-files=all \
    && \
    git diff --name-only $(git fork-point) | sed -E \"s/^/C  /\" \
    ) | sort --key=2 --unique \
    '

  ctags = !.git/hooks/ctags $@
  ctags-bundle = !.git/hooks/ctags-bundle
  ed = !$EDITOR -p `git diff --name-only $@ | uniq`
  who = shortlog --numbered --summary --

  find-merge = !sh -c ' \
    commit=$0 \
    && branch=${1:-HEAD} \
    && ( \
      git rev-list $commit..$branch --ancestry-path | cat -n \
      && git rev-list $commit..$branch --first-parent | cat -n \
    ) \
    | sort --key=2 \
    | uniq -f1 -d \
    | sort -n \
    | tail -1 \
    | cut -f2 \
    '
  show-merge = !sh -c ' \
    merge=$(git find-merge $0 $1) \
    && [ -n \"$merge\" ] \
    && git l $merge^..$merge \
    '
  hub-show-pr = "!sh -c 'open $(git hub-url)/pull/$( \
    git show-merge 5165557c9 \
    | ag --only-matching \"(?<=Merge pull request #)\\d+\" \
    | head -1 \
    ) \
    '"

  hub-url = !sh -c 'echo https://github.com/$( \
      git remote --verbose \
      | ag --only-matching \"(?<=git@github.com:)(.*)(?=\\.git \\(push\\))\" \
    ) \
    '
  hub-pr = !sh -c 'open $(git hub-url)/compare/$(git main-branch)...$(git current-branch)'

  sup = "!sh -c 'for branch in $(git branch --no-merged); do \
    git l $branch ^$(git main-branch); \
    echo ''; \
    done \
    '"
  x = !sh -c 'git $1 HEAD ^$(git merge-base --fork-point $0) $2'
  nuke = "!git branch -D $1; git push origin :$1"
  rubocop = !sh -c 'bin/rubocop-git $(git fork-point)) HEAD'

[commit]
  gpgsign = true

[push]
  default = current

[init]
  templatedir = ~/.git_template

[diff]
  # For Github-style word diffs
  wordRegex = [^[:space:]]

[color]
  ui = auto
  interactive = auto

[color "diff"]
  # Color syntax: <foreground> <background>
  # So "normal red" is normal foreground, red background
  # BUT bold is a modifier, so "bold green red" means
  #   "bold green" foreground, red background
  whitespace = red reverse
  plain = white
  meta = cyan
  frag = magenta bold
  old = red
  new = green
  commit = yellow

[color "diff-highlight"]
  oldNormal = red bold
  oldHighlight = red bold 52
  newNormal = green bold
  newHighlight = green bold 22

[pull]
  rebase = true

[filter "lfs"]
  clean = git lfs clean %f
  smudge = git lfs smudge %f
  required = true

[merge]
  tool = vimdiff

[merge "railsschema"]
  name = newer Rails schema version
  driver = "ruby -e '\n\
    system %(git), %(merge-file), %(--marker-size=%L), %(%A), %(%O), %(%B)\n\
    b = File.read(%(%A))\n\
    b.sub!(/^<+ .*\\nActiveRecord::Schema\\.define.:version => (\\d+). do\\n=+\\nActiveRecord::Schema\\.define.:version => (\\d+). do\\n>+ .*/) do\n\
      %(ActiveRecord::Schema.define(:version => #{[$1, $2].max}) do)\n\
    end\n\
    File.open(%(%A), %(w)) {|f| f.write(b)}\n\
    exit 1 if b.include?(%(<)*%L)'"

[gpg]
  program = gpg2
[diff-so-fancy]
  stripLeadingSymbols = false
  useUnicodeRuler = false
  markEmptyLines = false
